## here's a comment

## declare a variable using 'let'
let x = 5
	
## modify its value using '<-'
x <- 10

## use it in an expression
x + 5 / 2 

## arithmetic operators:
## +     addition
## -     subtraction
## *     multiplication
## /     division
## %     remainder

## sylt comes with a number of built in
## functions as part of its standard
## library. for example 'printLn'
## prints its argument to the console,
## followed by a newline character

printLn("Hello, World!")
	
## declare a function by adding a set of
## parentheses, optionally containing a comma-
## separated parameter list, after the name.
## the expression after the equal sign
## is the function body, it will not be
## executed until the function is called
	
let addNumbers(a, b) = a + b

## calling a function:
	
let result = addNumbers(5, 3)
ensure(result = 8) ## errors if not true

## use a block expression for multiple lines
## of code. the last expression in a block
## is returned implicitly:

let multiplyBySomething(x) = {
	let factor = 8
	x * factor
}

## this applies even outside of functions:

## prints '123'
printLn({ 123 })

## an empty block returns 'nil':

let empty = {}

## nil is the value that represents nothing
## it is mainly used when there is no
## meaningful value for an expression to
## return

let nilVal = nil
	
## anonymous functions (lambdas) can be
## created using the 'fun' keyword.
## functionally they're identical to regular
## functions
	
rep(fun(n) -> printLn((n + 1) * 2.5), 3)
	
## prints:
## 2.5
## 5
## 7.5

## booleans

## a boolean is either true or false.
## the comparison and equality operators
## all return booleans

## comparison operators:
## <     less than
## <=    less than or equal to
## >     greater
## >=    greater than or equal to

## equality operators:
## =     is equal to
## !=    is not equal to
	
## branch using 'if/else'

let greaterThanHalf(n) =
	if (n > 0.5) "hi"
	else "lo"
	
## an if without a matching else will return
## nil if the condition evaluates to false

let result = if (1 > 2) "hi"

## is the same as:

let result = if (1 > 2) "hi" else nil
	
## example of a loop using recursion
	
let countdown(i) =
	if (i > 0) {
		printLn(i)
		countdown(i - 1)
	}

countdown(3)
			
## prints:
## 3
## 2
## 1

## some example functions:

## geometry
let rectIsSquare(w, h) = (w = h)	
let rectArea(w, h) = w * h
let circleIsRound() = true	
let circleArea(radius) =
	Math.pi * Math.pow(radius, 2)
	
## electricity (Ohm's law)
let calcVoltage(current, resistance) =
	current * resistance

let calcCurrent(voltage, resistance) =
	voltage / resistance
		
let calcResistance(voltage, current) =
	voltage / current

## strings

## a string literal consists of any series of
## characters inside two doublequotes

let str = "Some text here"

## strings may contain escape sequences,
## which are special combinations of
## characters that translate to a byte

## all escape sequences begin with a
## backslash

## they are:
## \xff   hexadecimal byte
## \\     backslash
## \"     quote
## \t     tab
## \n     newline
## \r     carriage return
## \0     null terminator

## example:
let newline = "two\nlines"

## to create a list:
let list = [1, 2, 3]

## getting value at an index:
list[0]

## storing value at an index:
list[0] <- 10

## negative index counts from the end
ensure(list[-1] = list[List.length(list) - 1])

## example programs:

## generating a list of even numbers:
let values = List.range(1, 10)
values <- List.filter(isEven, values)
printLn(values)

## generating a random alphanumeric string:
Math.seedRand(Sys.time())
let genRandomString() = {
	let chars = String.chars(
		String.alpha ++ String.digits)

	let str = ""
	rep(fun(_) -> {
		let n = Math.rand(
			0, List.length(chars))
		str <- str ++ chars[n]
	}, 24)
	
	str
}

printLn(genRandomString())

## computing π using Leibniz’s formula:
let computePi() = {
	let pi = 0
	let k = 1
	let precision = 140000

	rep(fun(i) -> {
		pi <-
			if (i % 2 = 0) pi + 4 / k
			else pi - 4 / k
		k <- k + 2
	}, precision)
	
	pi
}

let pi = computePi()
printLn(pi)
ensure(Math.floatEq(pi, Math.pi, 0.0001))

## normalizing a 3D vector:
let length(v) = Math.sqrt(square(v[0])
	+ square(v[1]) + square(v[2]))

let normalize(v) = {
	let len = length(v)
	v[0] <- v[0] / len
	v[1] <- v[1] / len
	v[2] <- v[2] / len
}

let vec = [1, 2, -3]
normalize(vec)

printLn(vec)
