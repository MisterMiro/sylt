## note: most of the standard library is
## implemented in C

## Prelude   |
## ===========

let isZero(n) = n = 0
let isOne(n) = n = 1
let isPositive(n) = n >= 0
let isNegative(n) = n < 0
let isEven(n) = n % 2 = 0
let isOdd(n) = n % 2 = 1

let twice(n) = n * 2
let half(n) = n / 2
let squared(n) = n * n

let add(a, b) = a + b
let sub(a, b) = a - b
let mul(a, b) = a * b
let div(a, b) = a / b
let rem(a, b) = a % b

let rep(f, n) = {
	let i = 0
	while (i < n) {
		f(i)
		i <- i + 1
	}
}

## List      |
## ===========

let impl = {

let iter(f, list) =
	rep(fun(i) -> f(i, list[i]),
		List.length(list))

let forEach(f, list) =
	rep(fun(i) -> f(list[i]),
		List.length(list))

let map(f, list) = {
	let mapped = []
	List.forEach(fun(value) ->
		List.push(mapped, f(value)), list)
	mapped
}

let filter(f, list) = {
	let filtered = []
	List.forEach(fun(value) ->
		if (f(value))
			List.push(filtered, value), list)
	filtered
}

let fold(f, init, list) = {
	let folded = init
	List.forEach(fun(value) ->
		folded <- f(folded, value), list)
	folded
}

let sum(list) =
	List.fold(add, 0, list)

let average(list) =
	if (List.isEmpty(list)) 0
	else List.sum(list) / List.length(list)
	
let mean(list) = 
	if (isOdd(List.length(list)))
		list[List.length(list) / 2]
	else
		List.average([
			list[List.length(list) / 2 - 1],
			list[List.length(list) / 2]])

let flatten(list) = {
	let flat = []
	List.forEach(fun(item) ->
		if (typeOf(item) = "List")
			flat <- flat ++ List.flatten(item)
		else
			List.push(flat, item), list)
	flat
}

let dedup(list) = {
	let deduped = []
	List.forEach(fun(item) ->
		if (!List.contains(deduped, item))
			List.push(deduped, item), list)
	deduped
}

let any(f, list) =
	List.fold(fun(any, value) ->
		any or f(value), false, list)

let all(f, list) =
	List.fold(fun(all, value) ->
		all and f(value), true, list)

gdict["List"]["iter"] <- iter
gdict["List"]["forEach"] <- forEach
gdict["List"]["map"] <- map
gdict["List"]["filter"] <- filter
gdict["List"]["fold"] <- fold
gdict["List"]["sum"] <- sum
gdict["List"]["average"] <- average
gdict["List"]["mean"] <- mean
gdict["List"]["flatten"] <- flatten
gdict["List"]["dedup"] <- dedup
gdict["List"]["any"] <- any
gdict["List"]["all"] <- all

}

## String    |
## ===========

let impl = {

let leftPad(str, w, ch) = {
	let n = (w - String.length(str))
		/ String.length(ch)
	
	let text = ""
	rep(fun(_) -> text <- text ++ ch, n)
	text ++ str
}

let rightPad(str, w, ch) = {
	let n = (w - String.length(str))
		/ String.length(ch)
	
	let text = str
	rep(fun(_) -> text <- text ++ ch, n)
	text
}

let centerPad(str, w, ch) = {
	let n = (w - String.length(str))
		/ String.length(ch)
	
	let text = ""
	rep(fun(_) -> text <- text ++ ch, half(n))
	text <- text ++ str
	rep(fun(_) -> text <- text ++ ch, half(n))
	text
}

let fmt(str) = {
	let chars = String.chars(str)
	let text = ""
	let expr = ""
	
	let i = 0
	let inExpr = false
	while (i < List.length(chars)) {
		if (chars[i] = "%") {
			inExpr <- !inExpr
			
			if (inExpr) {
				## start of expression
				i <- i + 1
			
			} else {
				## end of expression
				let value = eval(expr)
				let value = asString(value)
				text <- text ++ value
						
				i <- i + String.length(expr)
				expr <- ""
			}
			
		} else {
			if (inExpr)
				expr <- expr ++ chars[i]
			else
				text <- text ++ chars[i]
			i <- i + 1
		}
	}
	
	if (inExpr)
		Sys.halt("unterminated interpolation")
	
	text
}

gdict["String"]["leftPad"] <- leftPad
gdict["String"]["rightPad"] <- rightPad
gdict["String"]["centerPad"] <- centerPad
gdict["String"]["fmt"] <- fmt

}

## Math      |
## ===========

let impl = {

let factorial(n) =
	if (n < 1) 1
	else n * factorial(n - 1)
	
gdict["Math"]["factorial"] <- factorial

}
