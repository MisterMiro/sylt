
## helper functions

let repn(n, f) = {
	let loop(i) =
		if i < n {
			f(i)
			loop(i + 1)
		}
		
	loop(0)
}
	
let foreach(ls, f) = {
	let loop(i) =
		if i < length(ls) {
			f(i, ls[i])
			loop(i + 1)
		}
		
	loop(0)
}

let map(ls, f) = {
	let newls = []
	foreach(ls, fun(_, v) = push(newls, f(v)))
	newls
}

let concat(a, b) = {
	let result = []
	foreach(a, fun(_, v) = push(result, v))
	foreach(b, fun(_, v) = push(result, v))
	result
}

## test functions

let names() = {
	let value = "whatever"
	
	let name = value
	let Name = value
	let NAME = value
	let _name = value
	let _name_ = value
	let name123 = value
	let name_123 = value
	
	## names that start with keywords
	let nilpotent = value
	let true_to_life = value
	let falsetto = value
	let letter = value
	let funambulism = value
	let iffy = value
	let elsewhere = value
	let andante = value
	let oracle = value
}

let strings() = {
	let alpha = "abcDEFGHijklMNOPqrstUVWxyz"
	
	## escape sequences
	let backslash = "\\"
	let quote = "\""
	let carriage_return = "\r"
	let newline = "\n"
	let tab = "\t"
	let null = "\0"
}

let numbers() = {
	let integer = 123456789
	let fractional = 3.141592
}

let addition() = {
	let x = 8
	let y = 12
	let sum = 20
	
	ensure(x + y == sum)
	
	## commutative
	ensure(y + x == sum)
	ensure(x + y == y + x)
}

let subtraction() = {
	let x = 20
	let y = 12
	let difference = 8
	
	ensure(x - y == difference)
	
	## not commutative
	ensure(y - x != difference)
	ensure(x - y != y - x)
}

let multiplication() = {
	let x = 5
	let y = 16
	let product = 80
	
	ensure(x * y == product)
	
	## commutative
	ensure(y * x == product)
	ensure(x * y == y * x)
}

let division() = {
	let x = 33
	let y = 3
	let quotient = 11
	
	ensure(x / y == quotient)
	
	## not commutative
	ensure(y / x != quotient)
	ensure(x / y != y / x)
}

let euclidean_division() = {
	let x = 17
	let y = 12
	let remainder = 5
	
	ensure(x % y == remainder)
	
	## not commutative
	ensure(y % x != remainder)
	ensure(x % y != y % x)
	
	## remainder is always positive
	ensure(7 % 3 == 1)
	ensure(7 % -3 == 1)
	ensure(-7 % 3 == 2)
	ensure(-7 % -3 == 2)
}

let unary_minus() = {
	let x = 25
	ensure(-x == 0 - x)
}

let arithmetic() = {
	let a = 1
	let b = a + 2
	ensure(a + b == a - (-b))
}

let comparison() = {
	let hi = 100
	let lo = -100
	
	ensure(lo < hi)
	ensure(lo <= hi)
	
	ensure(hi > lo)
	ensure(hi >= lo)
	
	let same = 70
	ensure(same <= same)
	ensure(same >= same)
}

let equality() = {
	let func_val() = 1 > 2
	
	## contains a value of each type
	let values = [
		nil,        ## Nil
		true,       ## Bool
		235,	    ## Num
		[123],	  ## List
		"'_'",	  ## String
		func_val,   ## Func
	]
	
	foreach(values, fun(slot, target) = {
		## equal to itself
		ensure(target == target)
		
		## not equal to a value of any other
		## type
		foreach(values, fun(idx, v) =
			if idx != slot {
				ensure(target != v)
			}
		)
	})
	
	## perform more type-specific tests
	
	ensure(true != false)
	
	ensure([] == [])
	ensure([[]] == [[]])
	ensure([0] != [1])
	
	ensure("" == "")
	ensure("ABC" != "abc")
	
	ensure(raise != sqrt)
}

let bool_not() = {
	ensure(true == !false)
	ensure(false == !true)
}

let bool_and() = {
	ensure((false and false) == false)
	ensure((false and true) == false)
	ensure((true and false) == false)
	ensure((true and true) == true)
	
	## short-circuit evaluation
	let would_crash() = ensure(false)
	false and would_crash()
}

let bool_or() = {
	ensure((false or false) == false)
	ensure((false or true) == true)
	ensure((true or false) == true)
	ensure((true or true) == true)
	
	## short-circuit evaluation
	let would_crash() = ensure(false)
	true or would_crash()
}

let blocks() = {
	## empty block returns nil
	let result = {}
	ensure(result == nil)
	
	## last expression is returned and...
	let result = {123}
	ensure(result == 123)
	
	## ...variables do not break anything...
	let result = {
		let v1 = 13
		let v2 = 17
		123
	}
	ensure(result == 123)
	
	## ...and neither do captured values
	let c = 35
	let result = {
		let v = 9
		let sum = c + v
		123
	}
	ensure(result == 123)
}

let if_else() = {
	## implicit nil
	let result = if false {}
	ensure(result == nil)
	
	## if branch
	let result = if true { "A" } else { "B" }
	ensure(result == "A")
	
	## else branch
	let result = if false { "A" } else { "B" }
	ensure(result == "B")
}

let functions() = {
	## empty body returns nil
	let empty() = {}
	ensure(empty() == nil)
	
	## arguments
	let add(a, b) = a + b
	ensure(add(3, 4) == 7)
	
	## accessing variable outside of
	## a functions stack window
	let outside = "outside"
	let f() = outside
	ensure(f() == outside)
	
	## moving surrounding context to
	## the heap if necessary
	let f() = {
		let keep = "jewel"
		let f2() = keep
		f2
	}
	ensure(f()() == "jewel")
	
	## anonymous functions using 'fun'
	let anon = fun(r, s, t) = r * s * t
	ensure(anon(2, 4, 8) == 64)
}

let recursion() = {
	let clear(ls) =
		if length(ls) > 0 {
			pop(ls)
			clear(ls)
		}
		
	let list = [1, 2, 3]
	clear(list)
	ensure(length(list) == 0)
}

let prelude_lib() = {
	## repn
	let nums = []
	repn(3, fun(i) = push(nums, (i + 1) * 3))
	ensure(nums == [3, 6, 9])
	
	## map
	let list = map([4, 8], fun(x) = x * 2)
	ensure(list == [8, 16])

	## concat
	let a = [1, 2]
	let b = [3, 4]
	let conced = concat(a, b)
	ensure(conced == [1, 2, 3, 4])
}

let math_lib() = {
	ensure(abs(-8) == 8)
	
	ensure(raise(2, 8) == 256)
	ensure(sqrt(256) == 16)
	
	let x = 32
	##ensure(raise(x, 0.5) == sqrt(x))
}

## tests to run

let parser = [
	names,
	strings,
	numbers,
]

let numbers = [
	addition,
	subtraction,
	multiplication,
	division,
	euclidean_division,
	unary_minus,
	arithmetic,
]

let boolean_ops = [
	comparison, equality,
	bool_not, bool_and, bool_or,
]

let control_flow = [
	blocks,
	if_else,
	functions,
	recursion,
]

let standard_lib = [
	prelude_lib,
	math_lib,
]

let run = []
concat(run, parser)
concat(run, numbers)
concat(run, boolean_ops)
concat(run, control_flow)
concat(run, standard_lib)

## let's go

let iterations = 1
repn(iterations, fun(_) = foreach(run,
	fun(_, f) = f()))

put("all tests passed")
