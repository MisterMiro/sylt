
## helper functions

let repn(n, f) = {
	let loop(i) =
		if i < n {
			f(i)
			loop(i + 1)
		}
	
	loop(0)
}

let foreach(ls, f) = {
	let loop(i) =
		if i < length(ls) {
			f(i, ls[i])
			loop(i + 1)
		}
		
	loop(0)
}

let map(ls, f) = {
	let mapped = []
	foreach(ls, fun(_, v) ->
		push(mapped, f(v)))
	mapped
}

let concat(a, b) = {
	let result = []
	foreach(a, fun(_, v) -> push(result, v))
	foreach(b, fun(_, v) -> push(result, v))
	result
}

let concat_mut(a, b) = {
	foreach(b, fun(_, v) -> push(a, v))
	nil
}

let flatten(ls) = {
	let flat = []
	let loop(i) =
		if i < length(ls) {
			let item = ls[i]
			
			if typeof(item) == "List" {
				let rec = flatten(item)
				concat_mut(flat, rec)
				
			} else {
				push(flat, item)
			}
			
			loop(i + 1)
		}
		
	loop(0)
	flat
}

let any(ls, f) = {
	let loop(i) =
		if i < length(ls) {
			if f(ls[i]) {
				true
			} else {
				loop(i + 1)
			}
		} else {
			false
		}
		
	loop(0)
}

let all(ls, f) = {
	let loop(i) =
		if i < length(ls) {
			if !f(ls[i]) {
				false
			} else {
				loop(i + 1)
			}
		} else {
			true
		}
		
	loop(0)
}

## test functions

let names() = {
	let value = "whatever"
	
	let name = value
	let Name = value
	let NAME = value
	let _name = value
	let _name_ = value
	let name123 = value
	let name_123 = value
	
	## names that start with keywords
	let nilpotent = value
	let true_to_life = value
	let falsetto = value
	let letter = value
	let funambulism = value
	let iffy = value
	let elsewhere = value
	let matchmaker = value
	let withdrawer = value
	let andante = value
	let oracle = value
}

let strings() = {
	let empty = ""
	
	let alpha = "abcDEFGHijklMNOPqrstUVWxyz"
	
	## all escape sequences...
	let hex = "\x41"
	let backslash = "\\"
	let quote = "\""
	let tab = "\t"
	let newline = "\n"
	let carriage_return = "\r"
	let null = "\0"
	
	## ...translate properly
	ensure(hex == "A")
	ensure(backslash == "\x5c")
	ensure(quote == "\x22")
	ensure(tab == "\x09")
	ensure(newline == "\x0a")
	ensure(carriage_return == "\x0d")
	ensure(null == "\x00")
}

let numbers() = {
	let integer = 123456789
	let fractional = 3.141592
}

let precedence() = {
	## multiplication > addition
	ensure(5 * 2 + 8 == 18)
	ensure(5 / 2 + 8 == 10.5)
	ensure(5 % 2 + 8 == 9)
	
	ensure(10 * 2 - 8 == 12)
	ensure(10 / 2 - 8 == -3)
	ensure(10 % 2 - 8 == -8)
	
	## addition > comparison
	ensure(1 < 1 + 1)
	ensure(1 <= 1 + 1)
	ensure(2 > 1 - 1)
	ensure(2 >= 1 - 1)
	
	## comparison > equality
	ensure(true == 1 < 2)
	ensure(true == 1 <= 2)
	ensure(true != 1 > 2)
	ensure(true != 1 >= 2)
}

let addition() = {
	let x = 8
	let y = 12
	let sum = 20
	ensure(x + y == sum)
	
	## commutative
	ensure(y + x == sum)
	ensure(x + y == y + x)
}

let subtraction() = {
	let x = 20
	let y = 12
	let difference = 8
	ensure(x - y == difference)
	
	## not commutative
	ensure(y - x != difference)
	ensure(x - y != y - x)
}

let multiplication() = {
	let x = 5
	let y = 16
	let product = 80
	ensure(x * y == product)
	
	## commutative
	ensure(y * x == product)
	ensure(x * y == y * x)
}

let division() = {
	let x = 33
	let y = 3
	let quotient = 11
	ensure(x / y == quotient)
	
	## not commutative
	ensure(y / x != quotient)
	ensure(x / y != y / x)
}

let euclidean_division() = {
	let x = 17
	let y = 12
	let remainder = 5
	ensure(x % y == remainder)
	
	## not commutative
	ensure(y % x != remainder)
	ensure(x % y != y % x)
	
	## remainder is always positive
	ensure(7 % 3 == 1)
	ensure(7 % -3 == 1)
	ensure(-7 % 3 == 2)
	ensure(-7 % -3 == 2)
}

let unary_minus() = {
	let x = 25
	ensure(-x == 0 - x)
	
	## double negative
	ensure(--x == x)
	
	## quadruple negative
	ensure(----x == x)
}

let arithmetic() = {
	let a = 1
	let b = a + 2
	ensure(a + b == a - (-b))
}

let comparison() = {
	let hi = 100
	let lo = -100
	
	ensure(lo < hi)
	ensure(lo <= hi)
	
	ensure(hi > lo)
	ensure(hi >= lo)
	
	let same = 70
	ensure(same <= same)
	ensure(same >= same)
}

let equality() = {
	let func_val() = 1 > 2
	
	## contains a value of each type
	let values = [
		nil,        ## Nil
		true,       ## Bool
		235,	    ## Num
		[123],	  ## List
		"'_'",	  ## String
		func_val,   ## Func
	]
	
	foreach(values, fun(slot, target) -> {
		## equal to itself
		ensure(target == target)
		
		## not equal to a value of any other
		## type
		foreach(values, fun(idx, v) ->
			if idx != slot {
				ensure(target != v)
			}
		)
	})
	
	## perform more type-specific tests
	ensure(true != false)
	
	ensure([] == [])
	ensure([[]] == [[]])
	ensure([0] != [1])
	
	ensure("" == "")
	ensure("ABC" != "abc")
	
	ensure(raise != sqrt)
}

let bool_not() = {
	ensure(true == !false)
	ensure(false == !true)
}

let bool_and() = {
	ensure((false and false) == false)
	ensure((false and true) == false)
	ensure((true and false) == false)
	ensure((true and true) == true)
	
	## short-circuit evaluation
	let would_crash() = ensure(false)
	false and would_crash()
}

let bool_or() = {
	ensure((false or false) == false)
	ensure((false or true) == true)
	ensure((true or false) == true)
	ensure((true or true) == true)
	
	## short-circuit evaluation
	let would_crash() = ensure(false)
	true or would_crash()
}

let blocks() = {
	## empty block returns nil
	let result = {}
	ensure(result == nil)
	
	## last expression is returned and...
	let result = {123}
	ensure(result == 123)
	
	## ...variables do not break anything...
	let result = {
		let v1 = 13
		let v2 = 17
		123
	}
	ensure(result == 123)
	
	## ...and neither do captured values
	let c = 35
	let result = {
		let v = 9
		let sum = c + v
		123
	}
	ensure(result == 123)
}

let lists() = {
	let list = [1, 2, 3]
	
	## indexing
	ensure(list[0] == 1
		and list[1] == 2
		and list[2] == 3)
		
	## negative indices count from the end
	## i.e. index -1 is equivalent to len - 1
	ensure(list[1] == list[-2])
}

let functions() = {
	## empty body returns nil
	let empty() = {}
	ensure(empty() == nil)
	
	## argument passing
	let add(a, b) = a + b
	ensure(add(3, 4) == 7)
	
	## arguments + local variables
	let add(a, b) = {
		let stack_mate = 18
		a + b
	}
	ensure(add(3, 4) == 7)
	
	## accessing variable outside of
	## a functions stack window
	let outside = "outside"
	let f() = outside
	ensure(f() == outside)
	
	## moving surrounding context to
	## the heap if necessary
	let f() = {
		let keep = "jewel"
		let f2() = keep
		f2
	}
	ensure(f()() == "jewel")
	
	## anonymous functions using 'fun'
	let anon = fun(r, s, t) -> r * s * t
	ensure(anon(2, 4, 8) == 64)
	
	## recursion
	let clear(ls) =
		if length(ls) > 0 {
			pop(ls)
			clear(ls)
		}
		
	let list = [1, 2, 3]
	clear(list)
	ensure(length(list) == 0)
}

let if_else() = {
	## implicit nil
	ensure(if true {} == nil)
	ensure(if false {} == nil)
	ensure(if false {} else {} == nil)
	
	## if branch
	let result = if true { "A" } else { "B" }
	ensure(result == "A")
	
	## else branch
	let result = if false { "A" } else { "B" }
	ensure(result == "B")
}

let match_with() = {
	## wildcard only
	let result =
		match "Anything" with
		? -> "Wildcard"
	ensure(result == "Wildcard")
	
	## match first arm
	let result =
		match 100 with
		| 100 -> "Success"
		? -> nil
	ensure(result == "Success")
	
	## match last arm
	let result =
		match 200 with
		| 100 -> "Fail"
		| 200 -> "Success"
		? -> nil
	ensure(result == "Success")
	
	## match middle arm
	let result =
		match 150 with
		| 100 -> "Fail"
		| 150 -> "Success"
		| 200 -> "Fail #2"
		? -> nil
	ensure(result == "Success")
	
	## example
	let name(num) =
		match num with
		| 0 -> "Zero"
		| 1 -> "One"
		| 2 -> "Two"
		? -> "Too high"
		
	ensure(name(0) == "Zero")
	ensure(name(1) == "One")
	ensure(name(2) == "Two")
	ensure(name(3) == "Too high")
}

let prelude_lib() = {
	## tostring
	ensure(tostring(nil) == "nil")
	ensure(tostring(true) == "true"
		and tostring(false) == "false")
	ensure(tostring(707) == "707")
	ensure(tostring(["bananas", 18, true])
		== "[\"bananas\", 18, true]")
	ensure(tostring(repn) == "repn()")
	
	## typeof
	ensure(typeof(nil) == "Nil")
	ensure(typeof(true) == "Bool")
	ensure(typeof(1) == "Num")
	ensure(typeof([]) == "List")
	ensure(typeof("") == "String")
	ensure(typeof(fun() -> {}) == "Function")
}

let list_lib() = {
	## length
	ensure(length([]) == 0)
	ensure(length([1]) == 1)
	ensure(length([1, 2]) == 2)
	
	## push...
	let x = []
	push(x, 3) ## = [3]
	ensure(x == [3] and length(x) == 1)
	push(x, 7) ## = [3, 7]
	ensure(x == [3, 7] and length(x) == 2)
	
	## ...and pop
	pop(x) ## = [3]
	ensure(x == [3] and length(x) == 1)
	pop(x) ## = []
	ensure(x == [] and length(x) == 0)
	
	## concat
	let a = [1, 2]
	let b = [3, 4]
	let concatenated = concat(a, b)
	ensure(concatenated == [1, 2, 3, 4])
	
	## concat_mut
	let a = [1, 2]
	let b = [3, 4]
	let result = concat_mut(a, b)
	ensure(result == nil)
	ensure(a == [1, 2, 3, 4])
}

let iter_lib() = {
	## repn
	let nums = []
	repn(3, fun(i) -> push(nums, (i + 1) * 3))
	ensure(nums == [3, 6, 9])
	
	## foreach
	let indices = [0, 1, 2]
	let copy = []
	foreach(indices, fun(index, value) -> {
		ensure(index == indices[index])
		push(copy, value)
	})
	ensure(copy == indices)
	
	## map
	let list = map([4, 8], fun(x) -> x * 2)
	ensure(list == [8, 16])

	## flatten
	let mess = [1, [2, [3, 4]], 5]
	let clean = flatten(mess)
	ensure(clean == [1, 2, 3, 4, 5])
	
	## any
	let set = [true, true, false]
	ensure(any(set, fun(v) -> v))
	ensure(any(set, fun(v) -> !v))
	pop(set) ## = [true, true]
	ensure(any(set, fun(v) -> v))
	ensure(!any(set, fun(v) -> !v))
	
	## all
	let set = [5, 7]
	ensure(all(set, fun(n) -> n >= 5))
	ensure(all(set, fun(n) -> !(n < 5)))
	push(set, 3) ## = [5, 7, 3]
	ensure(!all(set, fun(n) -> n >= 5))
	ensure(!all(set, fun(n) -> !(n < 5)))
}

let math_lib() = {
	## pi
	ensure(nearly(pi(), 3.141592, 0.001))
	
	## eulers
	ensure(nearly(eulers(), 2.718281, 0.001))
	
	## nearly
	let zero = 0
	let val = 0.005
	let epsilon = 0.01
	
	ensure(nearly(zero, val, epsilon))
	ensure(!nearly(zero, epsilon, epsilon))
	
	## abs
	ensure(abs(-8) == 8 and abs(8) == 8)
	
	## log and raise
	let target = 8
	let bases = [
		## common
		2, eulers(), 10,
		## uncommon
		3, 14, 2000, 18000, 2000000,
	]
	
	let log_and_raise(base, target) = {
		let power = log(target, base)
		let result = raise(base, power)
		ensure(nearly(result, target, 0.01))
	}
	
	foreach(bases, fun(_, base) ->
		log_and_raise(base, target))
	
	## sqrt
	ensure(sqrt(256) == 16)
	ensure(raise(32, 0.5) == sqrt(32))
	
	## floor, ceil and round
	let check_rounding(n) = {
		let low = n + 0.2
		let mid = n + 0.5
		let high = n + 0.8
	
		ensure(floor(low) == n)
		ensure(floor(high) == n)
	
		ensure(ceil(low) == n + 1)
		ensure(ceil(high) == n + 1)
	
		ensure(round(low) == n)
		ensure(round(high) == n + 1)
	
		ensure(round(mid) ==
			if n >= 0 {
				n + 1
			} else {
				n
			})
	}
	
	check_rounding(-4)
	check_rounding(0)
	check_rounding(4)
	
	## rads and degs
	ensure(nearly(rads(1), 0.0175, 0.001))
	ensure(nearly(degs(1), 57.296, 0.001))
	
	## sin, cos, tan
	ensure(nearly(sin(90), 0.8939, 0.001))
	ensure(nearly(cos(90), -0.4480, 0.001))
	ensure(nearly(tan(90), -1.9952, 0.001))
}

## tests to run

let run = flatten([
	"Parser",	## category name
	[			## functions to test
		names,
		strings,
		numbers,
		precedence,
	],
	"Numbers",
	[
		addition,
		subtraction,
		multiplication,
		division,
		euclidean_division,
		unary_minus,
		arithmetic,
	],
	"Booleans",
	[
		comparison,
		equality,
		bool_not,
		bool_and,
		bool_or,
	],
	"General",
	[
		blocks,
		lists,
		functions,
	],
	"Control flow",
	[
		if_else,
		match_with,
	],
	"Standard library",
	[
		prelude_lib,
		list_lib,
		iter_lib,
		math_lib,
	],
])

## let's go

let iterations = 1
repn(iterations, fun(_) ->
	foreach(run, fun(_, val) -> {
		if (typeof(val) == "String") {
			put(val)
			putln(":")
		
		} else {
			put("  ")
			put(tostring(val))
			put(".....")
		
			## run it
			val()
		
			putln("Ok")
		}
	}))

putln("All tests passed!")
