## note: most of the standard library is
## implemented in C, only a small portion
## of it is implemented here

## calls f n times, passing the current
## iteration count to f
let rep(n, f) = {
	let i = 0
	while (i < n) {
		f(i)
		i <- i + 1
	}
}

## calls f for each item in the list,
## passing the index as the first argument,
## and the item as the second
let List.iter(list, f) =
	rep(List.length(list), fun(i) ->
		f(i, list[i]))

## calls f for each item in the list,
## passing the item as the argument
let List.forEach(list, f) =
	rep(List.length(list), fun(i) ->
		f(list[i]))

## passes each value in the list through f
let List.map(list, f) = {
	let mapped = []
	List.forEach(list, fun(value) ->
		List.push(mapped, f(value)))
	
	mapped
}

## returns a list containing all values
## that pass the predicate f
let List.filter(list, f) = {
	let filtered = []
	List.forEach(list, fun(value) ->
		if (f(value))
			List.push(filtered, value))
	
	filtered
}

## reduces a list down to a single value,
## with an initial value of init,
## passing the current accumulator as the
## first argument to f, and the current item
## as the second
let List.fold(list, init, f) = {
	let folded = init
	List.forEach(list, fun(value) ->
		folded <- f(folded, value))
	
	folded
}

## returns the sum of all numbers in a list
let List.sum(list) =
	List.fold(list, 0, fun(sum, value) ->
		sum + value)

## returns the average value in a list
## of numbers
let List.average(list) =
	if (List.isEmpty(list)) 0
	else List.sum(list) / List.length(list)

## returns a version of the original
## list with any nested lists flattened out
let List.flatten(list) = {
	let flat = []
	List.forEach(list, fun(item) ->
		if (typeOf(item) = "List") {
			let child = List.flatten(item)
			flat <- List.concat(flat, child)
		} else List.push(flat, item))
	
	flat
}

## returns true if any value in the list
## satisfies the predicate f
let List.any(list, f) =
	List.fold(list, false, fun(acc, val) ->
		acc or f(val))

## returns true if all values in the list
## satisfy the predicate f
let List.all(list, f) =
	List.fold(list, true, fun(acc, val) ->
		acc and f(val))

## returns n!
let Math.factorial(n) =
	if (n >= 1) n * Math.factorial(n - 1)
	else 1

## left pad
let Fmt.leftPad(str, w, ch) = {
	let n = w - String.length(str)
	n <- n / String.length(ch)
	
	let result = ""
	rep(n, fun(_) ->
		result <- String.concat(result, ch))
	
	String.concat(result, str)
}

## right pad
let Fmt.rightPad(str, w, ch) = {
	let n = w - String.length(str)
	n <- n / String.length(ch)
	
	let result = str
	rep(n, fun(_) ->
		result <- String.concat(result, ch))
	
	result
}

## center
let Fmt.center(str, w, ch) = {
	let n = w - String.length(str)
	n <- n / String.length(ch)
	
	let result = ""
	
	## left
	rep(n / 2, fun(_) ->
		result <- String.concat(result, ch))
	
	result <- String.concat(result, str)
	
	## right
	rep(n / 2, fun(_) ->
		result <- String.concat(result, ch))
		
	result
}
