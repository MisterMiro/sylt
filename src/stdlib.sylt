## note: most of the standard library is
## implemented in C

ensure(System.version = "Sylt Dev 0.1")

## Prelude   |
## ===========

let isZero(n) = n = 0
let isOne(n) = n = 1
let isPositive(n) = n >= 0
let isNegative(n) = n < 0
let isEven(n) = n % 2 = 0
let isOdd(n) = n % 2 = 1

let incr(n) = n + 1
let decr(n) = n - 1

let add(a b) = a + b
let sub(a b) = a - b
let mul(a b) = a * b
let div(a b) = a / b
let rem(a b) = a % b

let rep(f n) = do
	let i = 0
	while i < n: do
		f(i)
		i <- incr(i)
	end
end

## List      |
## ===========

let impl = do
	let iter(f ls) = rep(fun i -> f(i List.get(i ls)) #ls)
	let forEach(f ls) = rep(fun i -> f(List.get(i ls)) #ls)

	let map(f ls) = do
		let newList = []
		List.forEach(fun value -> newList += f(value) ls)
		newList
	end

	let filter(f ls) = do
		let newList = []
		List.forEach(fun value -> if f(value): newList += value ls)
		newList
	end

	let fold(f init ls) = do
		let result = init
		List.forEach(fun value -> result <- f(result value) ls)
		result
	end

	let sum(ls) = List.fold(add 0 ls)
	let average(ls) = if ls = []: 0 else List.sum(ls) / #ls
		
	let mean(ls) = 
		if isOdd(#ls): List.get(#ls / 2 ls)
		else List.average([
			List.get(#ls / 2 - 1 ls)
			List.get(#ls / 2 ls)])

	let sortBy(f ls) = do
		let bubbleSort(ls n) = do
			let swapped = 0

			rep(fun i -> do
				if f(List.get(i ls) List.get(i + 1 ls)): do
					List.swap(i i + 1 ls)
					swapped += 1
				end
			end n - 1)

			if swapped != 0: bubbleSort(ls n - 1)
		end

		let n = #ls
		if n > 1: bubbleSort(ls n)
	end

	let sort(ls) = sortBy(fun a b -> a > b ls)

	let flatten(ls) = do
		let flat = []
		List.forEach(fun item -> flat += if typeOf(item) = "List": List.flatten(item) else item ls)
		flat
	end

	let dedup(ls) = do
		let deduped = []
		List.forEach(fun item -> if !List.contains(item deduped): deduped += item ls)
		deduped
	end

	let any(f ls) = List.fold(fun any value -> any or f(value) false ls)

	let all(f ls) = List.fold(fun all value -> all and f(value) true ls)

	let lib = Dict.get("List" gdict)
	Dict.set("iter" iter lib)
	Dict.set("forEach" forEach lib)
	Dict.set("map" map lib)
	Dict.set("filter" filter lib)
	Dict.set("fold" fold lib)
	Dict.set("sum" sum lib)
	Dict.set("average" average lib)
	Dict.set("mean" mean lib)
	Dict.set("sortBy" sortBy lib)
	Dict.set("sort" sort lib)
	Dict.set("flatten" flatten lib)
	Dict.set("dedup" dedup lib)
	Dict.set("any" any lib)
	Dict.set("all" all lib)
end

## String    |
## ===========

let impl = do
	let leftPad(str w pattern) = do
		let text = ""
		let n = (w - #str) / #pattern

		rep(fun _ -> text += pattern n)
		text + str
	end

	let rightPad(str w pattern) = do
		let text = str
		let n = (w - #str) / #pattern

		rep(fun _ -> text += pattern n)
		text
	end

	let centerPad(str w pattern) = do
		let text = ""
		let n = (w - #str) / #pattern

		rep(fun _ -> text += pattern n / 2)
		text += str
		rep(fun _ -> text += pattern n / 2)
		text
	end

	let fmt(str) = do
		let text = ""
		let expr = ""
		let chars = String.chars(str)
		
		let index = 0
		let isInExpr = false
		while index < #chars: do
			let character = List.get(index chars)

			if character = "%" and !isInExpr:
				isInExpr <- true
			else if character = "%" and isInExpr: do
				isInExpr <- false

				if #expr = 0: text <- text + "%"
				else do
					let result = eval(expr)
					text += toString(result)
					expr <- ""
				end
			end
			else do
				if isInExpr: expr += character
				else text += character
			end

			index += 1
		end
		
		if isInExpr: System.halt("unterminated interpolation")
		text
	end

	let lib = Dict.get("String" gdict)
	Dict.set("leftPad" leftPad lib)
	Dict.set("rightPad" rightPad lib)
	Dict.set("centerPad" centerPad lib)
	Dict.set("fmt" fmt lib)
end

let impl = do
	let fiftyFifty() = Rand.range(0 1) > 0.9999999 / 2
	let oneIn(n) = Rand.range(0 n) < 1
	let scramble(ls) = List.sortBy(fun _ _ -> fiftyFifty() ls)

	let lib = Dict.get("Rand" gdict)
	Dict.set("fiftyFifty" fiftyFifty lib)
	Dict.set("oneIn" oneIn lib)
	Dict.set("scramble" scramble lib)
end
