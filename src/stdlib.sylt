## note: most of the standard library is
## implemented in C

## Prelude   |
## ===========

let isZero(n) = n = 0
let isOne(n) = n = 1
let isPositive(n) = n >= 0
let isNegative(n) = n < 0
let isEven(n) = n % 2 = 0
let isOdd(n) = n % 2 = 1

let incr(n) = n + 1
let decr(n) = n - 1

let add(a b) = a + b
let sub(a b) = a - b
let mul(a b) = a * b
let div(a b) = a / b
let rem(a b) = a % b

let rep(f n) = {
	let i = 0
	while (i < n) {
		f(i)
		i <- incr(i)
	}
}

let printEach(ls) = List.forEach(printLn ls)

## List      |
## ===========

let impl = {
	let iter(f ls) = rep(fun i -> f(i ls[i]) List.length(ls))

	let forEach(f ls) = rep(fun i -> f(ls[i]) List.length(ls))

	let map(f ls) = {
		let mapped = []
		List.forEach(fun value -> List.push(mapped f(value)) ls)
		mapped
	}

	let filter(f ls) = {
		let filtered = []
		List.forEach(fun value ->
			if (f(value)) List.push(filtered value) ls)
		filtered
	}

	let fold(f init ls) = {
		let folded = init
		List.forEach(fun value -> folded <- f(folded value) ls)
		folded
	}

	let sum(ls) = List.fold(add 0 ls)

	let average(ls) =
		if (ls = []) 0
		else List.sum(ls) / List.length(ls)
		
	let mean(ls) = 
		if (isOdd(List.length(ls)))
			ls[List.length(ls) / 2]
		else
			List.average([
				ls[List.length(ls) / 2 - 1]
				ls[List.length(ls) / 2]])

	let sortBy(f ls) = {
		let bubbleSort(ls n) = {
			let swapped = 0

			rep(fun i -> {
				if (f(ls[i] ls[i + 1])) {
					let tmp = ls[i]
					ls[i] <- ls[i + 1]
					ls[i + 1] <- tmp

					swapped <- incr(swapped)
				}
			} n - 1)

			let done = swapped = 0
			if (!done)
				bubbleSort(ls n - 1)
		}

		let n = List.length(ls)
		if (n > 1)
			bubbleSort(ls n)
	}

	let sort(ls) = sortBy(fun a b -> a > b ls)

	let flatten(ls) = {
		let flat = []
		List.forEach(fun item ->
			if (typeOf(item) = "List") flat <- flat + List.flatten(item)
			else List.push(flat item) ls)
		flat
	}

	let dedup(ls) = {
		let deduped = []
		List.forEach(fun item ->
			if (!List.contains(deduped item))
				List.push(deduped item) ls)
		deduped
	}

	let any(f ls) = List.fold(fun any value -> any or f(value) false ls)

	let all(f ls) = List.fold(fun all value -> all and f(value) true ls)

	gdict["List"]["iter"] <- iter
	gdict["List"]["forEach"] <- forEach
	gdict["List"]["map"] <- map
	gdict["List"]["filter"] <- filter
	gdict["List"]["fold"] <- fold
	gdict["List"]["sum"] <- sum
	gdict["List"]["average"] <- average
	gdict["List"]["mean"] <- mean
	gdict["List"]["sortBy"] <- sortBy
	gdict["List"]["sort"] <- sort
	gdict["List"]["flatten"] <- flatten
	gdict["List"]["dedup"] <- dedup
	gdict["List"]["any"] <- any
	gdict["List"]["all"] <- all
}

## String    |
## ===========

let impl = {
	let leftPad(str w ch) = {
		let n = (w - String.length(str)) / String.length(ch)
		
		let text = ""
		rep(fun _ -> text <- text + ch n)
		text + str
	}

	let rightPad(str w ch) = {
		let n = (w - String.length(str)) / String.length(ch)
		
		let text = str
		rep(fun _ -> text <- text + ch n)
		text
	}

	let centerPad(str w ch) = {
		let n = (w - String.length(str)) / String.length(ch)
		
		let text = ""
		rep(fun _ -> text <- text + ch n / 2)
		text <- text + str
		rep(fun _ -> text <- text + ch n / 2)
		text
	}

	let fmt(str) = {
		let chars = String.chars(str)
		let text = ""
		let expr = ""
		
		let i = 0
		let inExpr = false
		while (i < List.length(chars)) {
			if (chars[i] = "%") {
				inExpr <- !inExpr
				
				if (inExpr) {
					## start of expression
					i <- incr(i)
				
				} else {
					## end of expression
					let value = eval(expr)
					let value = toString(value)
					text <- text + value
							
					i <- i + String.length(expr)
					expr <- ""
				}
				
			} else {
				if (inExpr) expr <- expr + chars[i]
				else text <- text + chars[i]
				i <- incr(i)
			}
		}
		
		if (inExpr)
			Sys.halt("unterminated interpolation")
		
		text
	}

	gdict["String"]["leftPad"] <- leftPad
	gdict["String"]["rightPad"] <- rightPad
	gdict["String"]["centerPad"] <- centerPad
	gdict["String"]["fmt"] <- fmt
}
